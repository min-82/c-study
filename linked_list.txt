1. 기본 개념: "기차 만들기"

    노드(Node): 데이터(화물)와 다음 노드의 주소(연결 고리)를 가진 하나의 덩어리.

    자기 참조 구조체: struct Node *next;를 통해 다음 노드의 위치를 저장함.

    특징: 배열처럼 메모리가 붙어 있지 않고 여기저기 흩어져 있어도 주소만 알면 연결 가능함.

2. 특정 위치 삽입(Insert)의 원리

    핵심: "기존 연결을 끊기 전에 새 연결을 먼저 만들어라."

    순서: 1. 새 노드를 만든다. 2. 새 노드의 next에 현재 노드의 next 주소를 복사한다. (뒤쪽 노드들 백업) 3. 현재 노드의 next가 새 노드를 가리키게 한다.

    주의: 순서가 바뀌면 뒤에 있던 노드들의 주소를 잃어버려 '데이터 미아'가 발생함.

3. 특정 노드 삭제(Delete)의 원리

    핵심: "나를 건너뛰고 앞사람과 뒷사람을 직접 연결하라."

    과정:

        prev(이전 노드)가 curr->next(나의 다음 노드)를 가리키게 수정.

        고립된 curr 노드를 free()로 메모리 해제.

4. 삭제 함수에서 이중 포인터(**)를 쓰는 이유 (중요!)

    상황: 리스트의 맨 첫 번째 노드(Head)를 삭제해야 할 때.

    문제: 함수에 그냥 head를 넘기면 주소값의 '복사본'만 전달됨. 함수 안에서 백날 고쳐도 메인 함수의 원본 head 쪽지는 바뀌지 않음.

    해결: &head를 통해 **"쪽지가 들어있는 주머니의 주소"**를 전달.

    결과: 함수 내부에서 *headAddr를 통해 메인 함수의 원본 포인터 변수 값을 직접 수정하여, 리스트의 시작점 자체를 다음 노드로 갈아치울 수 있음.

5. 안전한 메모리 해제 (Free)

    방법: temp 포인터에 다음 주소를 미리 저장한 뒤 현재 노드를 해제해야 함.

    이유: free(head)를 먼저 하면 head->next라는 정보 자체가 사라져서 다음 노드로 이사 갈 수 없기 때문.
